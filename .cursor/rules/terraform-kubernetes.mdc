---
description: Terraform and Kubernetes YAML conventions for kani-k8s
globs: terraform/**/*.tf,terraform/**/yamls/*.yaml
alwaysApply: false
---

# Terraform & Kubernetes YAML Conventions

Follow these patterns when editing Terraform or Helm values YAML in this repo. All comments must be in **English**.

---

## File layout

- **Root**: `terraform/do/` – module calls, root variables. Variables are split by domain: `kubernetes_variables.tf`, `domain_variables.tf`, `authentication_variables.tf`, etc.
- **Module**: `terraform/do/modules/kubernetes/` – DOKS cluster, Helm releases, DNS, secrets.
- **Global variables**: Use `global_variables_*.tf` pattern for shared variables used across multiple components:
  - `global_variables_resources.tf` → resource presets configuration
  - `global_variables_mount.tf` → encrypted secrets and GCP service account variables
  - `global_variables_kubernetes.tf` → Kubernetes cluster and node pool variables
  - `global_variables_gcp.tf` → GCP project ID variables
- **Per-component**:
  - One `*_variables.tf` → all variables of that component
  - One or more:
    - `*_locals.tf` → all locals (computed config)
    - `*_resources.tf` or `*_resources_*.tf` → pure Terraform resources (namespace, secret, ingress…)
      - Use `*_resources_*.tf` pattern to split resources by domain (e.g., `jenkins_resources_rbac.tf`, `jenkins_resources_init_groovy.tf`)
    - `*_helm.tf` → `helm_release`
- **YAML**: `terraform/do/modules/kubernetes/yamls/` – Helm values used by `templatefile()`.
  - Names match the chart (e.g. `jenkins.yaml`, `argo-cd.yaml`)
  - Do **not** add `_`-prefixed files here; use `yamls/legacy/` for full/default values reference (e.g. `_jenkins.yaml`)

---

## Comments (English only)

- **Use `//` only** for Terraform comments. Do not use `#` except when commenting out an entire block of code.
- **Block section**: Use a double-line banner with `//` and `=====` for main resource blocks (variables, locals, resources, helm releases):

```hcl
// =========================
// Argo CD controller (replica count + resources)
// =========================
// Argo CD is a declarative GitOps continuous delivery tool for Kubernetes.
// This section configures the controller component with replica count and resource limits.
```

- **Variable comments**: Add a single-line comment above each variable explaining its purpose:

```hcl
// Whether to install cert-manager Custom Resource Definitions (CRDs) during Helm chart installation
variable "cert_manager_install_crds" {
  type        = bool
  description = "Install cert-manager CRDs"
  default     = true
}

// Number of replicas for the cert-manager controller pod
variable "cert_manager_controller_replica_count" {
  type        = number
  description = "Number of cert-manager controller replicas"
  default     = 1
}
```

- **Locals structure**: Use three separate `locals` blocks per component file to prevent dependency cycles and self-references:

  1. **Inputs block** (`local.<component>_inputs`) – Contains preset mappings that are referenced by the main component block:
     - Presets mapping (maps component subcomponents to resource size keys)
  
  2. **Main component block** (`local.<component>`) – Contains static configuration that does not depend on data sources:
     - Resource requests/limits (computed from variables/presets, referencing `_inputs`)
     - Static naming conventions
     - Services configuration (service names and ports as hardcoded values)

  3. **Outputs block** (`local.<component>_outputs`) – Contains computed values that depend on data sources (e.g., `data.kubernetes_service`):
     - Service hosts (constructed from data sources)
     - Service ports (resolved from data sources, but should reference port from main block `services` when available)
     - Any other values that reference data sources

This separation prevents dependency cycles between data sources and locals. Each block should have its own comment section explaining its purpose.

```hcl
// =========================
// Prometheus inputs
// =========================
// Preset mappings for Prometheus components.
// Maps component subcomponents to resource size keys (16, 32, 64, etc.) for preset lookup.
locals {
  prometheus_inputs = {
    presets = {
      operator   = "16"
      prometheus = "32"
    }
  }
}

// =========================
// Prometheus computed values
// =========================
// Resource requests and limits for Prometheus components.
// Uses coalesce to prefer component-specific vars, fallback to preset, then hardcoded default.
// Also includes naming conventions.
locals {
  prometheus = {
    operator = {
      request_cpu = coalesce(
        var.operator_request_cpu,
        try(var.resources_config[local.prometheus_inputs.presets.operator].requests.cpu, "32m")
      )
      // ... more resource values
    }
    name = "kube-prometheus"
    // Services configuration
    // Defines service names and ports for all services exposed by this component.
    // Ports are hardcoded default values that match the service configuration.
    services = {
      server_service = {
        name = "kube-prometheus-prometheus"
        port = 9090
      }
      alertmanager_server_service = {
        name = "kube-prometheus-alertmanager"
        port = 9093
      }
    }
  }
}

// =========================
// Prometheus outputs
// =========================
// Service port resolution and computed service information.
// These values depend on data sources and are separated to avoid dependency cycles.
locals {
  prometheus_outputs = {
    server_service = {
      host = "${data.kubernetes_service.prometheus_server.metadata[0].name}.${kubernetes_namespace.prometheus.metadata[0].name}.svc.cluster.local"
      port = try(
        one([
          for p in data.kubernetes_service.prometheus_server.spec[0].port :
          p.port if p.port == local.prometheus.services.server_service.port
        ]),
        data.kubernetes_service.prometheus_server.spec[0].port[0].port
      )
    }
    alertmanager_server_service = {
      host = "${data.kubernetes_service.prometheus_alertmanager_server.metadata[0].name}.${kubernetes_namespace.prometheus.metadata[0].name}.svc.cluster.local"
      port = try(
        one([
          for p in data.kubernetes_service.prometheus_alertmanager_server.spec[0].port :
          p.port if p.port == local.prometheus.services.alertmanager_server_service.port
        ]),
        data.kubernetes_service.prometheus_alertmanager_server.spec[0].port[0].port
      )
    }
  }
}
```

The inputs block contains only preset mappings and has no dependencies. The main component block references `_inputs` for presets but should not reference data sources directly; use the `_outputs` block for data source-dependent values. All three blocks are placed in the same `*_locals.tf` file.

**Services pattern**: All components that expose Kubernetes services must define a `services` object in the main component block. Each service entry contains:
- `name`: The Kubernetes service name (hardcoded string)
- `port`: The default port number (hardcoded integer)

The outputs block should reference these port values when resolving service ports from data sources, using `local.<component>.services.<service_key>.port` instead of hardcoding port numbers in the try() expressions.

- **Templatefile comments**: Use simple inline comments (`//`) for grouping within `templatefile()` blocks, not full comment blocks:

```hcl
templatefile("${path.module}/yamls/cert-manager.yaml", {
  // Installation and replica counts
  install_crds              = var.cert_manager_install_crds
  controller_replica_count = var.cert_manager_controller_replica_count
  
  // Core component resources
  cert_manager_request_cpu = local.cert_manager.cert_manager.request_cpu
})
```